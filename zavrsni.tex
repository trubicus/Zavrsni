\documentclass[times, utf8, zavrsni]{fer}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{array}
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\graphicspath{ {./img/} }

\definecolor{lightgray}{rgb}{0.95, 0.95, 0.95}
\definecolor{darkgray}{rgb}{0.4, 0.4, 0.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{editorGray}{rgb}{0.95, 0.95, 0.95}
\definecolor{editorOcher}{rgb}{1, 0.5, 0} % #FF7F00 -> rgb(239, 169, 0)
\definecolor{editorGreen}{rgb}{0, 0.5, 0} % #007C00 -> rgb(0, 124, 0)
\definecolor{orange}{rgb}{1,0.45,0.13}		
\definecolor{olive}{rgb}{0.17,0.59,0.20}
\definecolor{brown}{rgb}{0.69,0.31,0.31}
\definecolor{purple}{rgb}{0.38,0.18,0.81}
\definecolor{lightblue}{rgb}{0.1,0.57,0.7}
\definecolor{lightred}{rgb}{1,0.4,0.5}

\lstdefinestyle{htmlcssjs} {%
  % General design
%  backgroundcolor=\color{editorGray},
  basicstyle={\footnotesize\ttfamily},   
  frame=b,
  % line-numbers
  xleftmargin={0.75cm},
  numbers=left,
  stepnumber=1,
  firstnumber=1,
  numberfirstline=true,	
  % Code design
  identifierstyle=\color{black},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{editorGreen}\bfseries,
  stringstyle=\color{editorOcher}\ttfamily,
  commentstyle=\color{brown}\ttfamily,
  % Code
  language=HTML5,
  alsolanguage=JavaScript,
  alsodigit={.:;},	
  tabsize=2,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
  % German umlauts
  literate=%
  {Ö}{{\"O}}1
  {Ä}{{\"A}}1
  {Ü}{{\"U}}1
  {ß}{{\ss}}1
  {ü}{{\"u}}1
  {ä}{{\"a}}1
  {ö}{{\"o}}1
}

% JavaScript
\lstdefinelanguage{JavaScript}{
  morekeywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  morecomment=[s]{/*}{*/},
  morecomment=[l]//,
  morestring=[b]",
  morestring=[b]'
}

% pocetak {{{
\begin{document}

% TODO: Navedite broj rada.
\thesisnumber{5417}

% TODO: Navedite naslov rada.
\title{Implementacija sustava za nadziranje i upravljanje bežičnim razvojnim modulima ESP8266}

% TODO: Navedite vaše ime i prezime.
\author{Ivan Trubić}

\maketitle

% Ispis stranice s napomenom o umetanju izvornika rada. Uklonite naredbu \izvornik ako želite izbaciti tu stranicu.
\izvornik

% Dodavanje zahvale ili prazne stranice. Ako ne želite dodati zahvalu, naredbu ostavite radi prazne stranice.
\zahvala{}

\tableofcontents
% }}}

% Uvod {{{
\chapter{Uvod}
ESP8266 je System on Chip (SoC) rješenje tvrtke Espresiff Systems vrlo malene površine mnogih mogučnosti.
Dizajniran je kao vrlo jeftin modul sa mogučnošću spajanja na WiFi mrežu te niskom potrošnjom energije što ga čini vrlo povoljnim za ugrađivanje u IoT (\textit{Internet Of Things}) uređaje.
U ovome će radu ESP8266 \textit{SoC} biti korišten kao krajnji čvor u sustavu bežičnog prikupljanja podataka, nadziranja te upravljanja koji komunicira s ostalim sustavom koristeći \textit{Message Queueing Telemetry Transport} protokol (MQTT).
Topologija takvog sustava se sastoji od krajnjeg čvora na kojem je spojen neki uređaj koji želimo kontrolirati ili nadzirati, pristupne točke WiFi mreži, poslužitelja na kojemu se nalaze MQTT broker za upravljanje porukama, baza podataka koja sadrži trenutne podatke čvorova te API kao sučelje između baze podataka i krajnjeg klijenta.
Ovakav sustav je vrlo jednostavan i jeftin za implementaciju te je izrazito jako skalibilan što znači da pisanjem vrlo jednostavnog programskog koda za pojedini čvor možemo u svoju mrežu postaviti virtualno beskonačno krajnjih čvorova kojima se vrlo jednostavno može upravljati. 
Cilj ovoga rada je napraviti gotov sustav otvorenoga koda koji će prateći \textit{Homie} konvenciju za MQTT protokol olakšati amaterima brzo rađenje prototipa bilo iz znatiželje, potrebe ili kreativnosti.
%}}}

\chapter{Razrada}

% ESP {{{
\section{ESP8266}
ESP8266 je \textit{SoC} koji u sebi ima mikrokontroler RISC arhitekture te WiFi modul za spajanje na mrežu.
Ciljano tržište za ovaj čip su hobisti koji žele neku svoju ideju pretvoriti u stvarnost na vrlo jednostavan način.
Dizajniran je vrlo jednostavno i kompaktno kako bi cijena čipa bila što niža te zato što je namjenjen za jednostavne i lokalizirane poslove koji uključuju upravljanje vrlo malim brojem uređaja odjednom.
Točno u tome leži prava snaga čipa jer možemo imati više čipova koji komuniciraju međusobno umjesto da imamo jedan snažan mikrokontroler koji će upravljati uređajima centralizirano.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{esp8266.jpg}
    \caption{ESP8266 \textit{SoC}}
\end{figure}
%}}}

% Znacajke {{{
\section{Značajke}
ESP8266 u sebi ima 32-bitni RISC mikrokontroler koji radi na frekvenciji od 80MHz.
Memorija se sastoji od:
\begin{itemize}
    \item 32 KiB instrukcijskog RAM-a
    \item 32 KiB priručne memorije instrukcijskog RAM-a
    \item 80 KiB korisničkog RAM-a
\end{itemize}
Vanjske QSPI \textit{flash} memorije do 16MiB ovisno o modelu, IEEE 802.11 b/g/n WiFi, 16 GPIO pina, SPI sučelje, softverska implementacija I2C protokola, I2S sučelje, UART te 10-bitni analogno-digitalni pretvornik.
%}}}

% Povezivost {{{
\section{Povezivost}
Najbitnije sučelje prema vanjskome svijetu na ESP8266 su bežična mreža i 16 GPIO pinova.
Mreža podržava IEEE 802.11 b/g/n protokol, P2P konfiguraciju te TCP/IP protokolni stog.
GPIO pinovi se mogu zasebno programirati kao ulazi/izlazi, postaviti im \textit{pull-up/down} otpornike, te svaki ima ugrađen 10 bitni digitalno-analogni pretvornik tako da se svaki pin ponaša kao analogni izlaz.
Ima također jedan analogan ulaz sa 10 bitnim analogno-digitalnim pretvornikom za spajanje raznih analognih senzora bez posebnih sučelja.
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{ESP-Pin-Out.png}
    \caption{Izvodi ESP8266}
\end{figure}
%}}}

% Programiranje{{{
\section{Programiranje} 
ESP8266 se može programirati na više različitih načina.
Originalno se programirao uz pomoć drugoga mikrokontrolera sve dok firma Espressif Systems nije izdala poseban \textit{SDK}(  eng. \textit{Software Development Kit} ) nakon čega to više nije bilo potrebno.
Nakon toga su se počeli javljat mnogi SDK-ovi ponajviše otvorenog koda zajednice programera od čega su najpoznatiji:
    \begin{itemize}
        \item NodeMCU - baziran na skriptnom programskom jeziku Lua
        \item Arduino - baziran na jeziku C++ iste sintakse kao i bilokoji arduino mikrokontroler
        \item PlatformIO - nova razina razvoja ugradbenih sustava sa posebnim IDE-om
        \item MicroPython - baziran na programskom jeziku python
    \end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{arduino.png}
    \caption{Arduino razvojno okruženje}
\end{figure}

Zbog velike raširenosti Arduino mikrokontrolera je zajednica programera razvila SDK za Arduino razvojno sučelje.
Cilj je bio približavanje ESP8266 modula amaterima te olakšanje razvoja firmware-a kroz poznatu sintaksu, poznato jednostavno razvojno okruženje te već postoječe biblioteke.
%}}}

%Usporedba {{{
\section{Usporedba drugih razvojnih modula koji koriste WiFi komunikacijski protokol sa ESP8266 modulom}
Pronalazak alternativnih modula se pokazalo izazovno zbog tolike raširenosti ESP modula.
U tablici~\ref{tab:usporedba} je vidljivo i zašto je to tako.
Moduli CC3000 i RN-131 su u zajednici i od strane proizvođača označeni kao NRND (engl. \textit{Not Recommended for New Designs}) jer više nisu podržani.
Cijenovno niti funkcionalno nisu više adekvatni za korištenje u \textit{IoT} svrhe.

%tablica {{{
    \begin{table}[h]
        \centering
        \resizebox{\columnwidth}{!}{
        \begin{tabular} { |c||c|c|c|c| }
            \hline
            \textbf{Kategorija} & \textbf{ESP8266} & \textbf{ESP32} & \textbf{CC3000} & \textbf{RN-131} \\
            \hline
            \hline
            \textbf{WiFi Standard} & 802.11 b/g/n & 802.11 b/g/n & 802.11 b/g & 802.11 b/g\\
            \hline
            \textbf{Tip paketa} & TCP i UDP & TCP i UDP & TCP i UDP & TCP i UDP\\
            \hline
            \textbf{Režim rada} & Klijent i Server & Klijent i Server & Klijent i Server & Klijent i Server\\
            \hline
            \textbf{AP režim} & P2P i Soft-AP & Soft-AP & Ne & Soft-AP\\
            \hline
            \textbf{Dimenzije [mm]} & 26x16x3 & 26x18x3 & 16.3x13.5x3 & 20x37x3.5\\
            \hline
            \textbf{Sučelje} & TTL-Serial & TTL-Serial & SPI & SPI\\
            \hline
            \textbf{Enkripcija} & WPA2-PSK & WPA2 i WAPI & WPA-PSK & WPA2-PSK\\
            \hline
            \textbf{Struja u sleep režimu rada} & <10 $\mu$A & 5 $\mu$A & ? & 4$\mu$A\\
            \hline
            \textbf{Struja napajanja} & 80mA & 500mA & ? & 40mA\\
            \hline
            \textbf{Napon napajanja} & 3.0-3.6V & 2.3-3.6V & 2.7-3.6V & 3.0-3.7\\
            \hline
            \textbf{Digitalni pinovi} & 9 & 34 & 0 & 10\\
            \hline
            \textbf{Analogni pinovi} & 1 & 18 & 0 & 8\\
            \hline
            \textbf{Sadrži mikrokontroler} & Da & Da & NE & Ne\\
            \hline
            \textbf{Cijena [\$]} & 6.95 & 8.95 & 34.95 & 35.38\\
            \hline
        \end{tabular}
        }
        \caption{usporedba značajki WiFi modula i cjena}\label{tab:usporedba}
    \end{table}
%}}}

C3000 i RN-131 moduli nemaju programljivi mikrokontroler, ne koriste suvremeni 802.11n standard koji je znatno brži te su cjenovno i po nekoliko puta skuplji od vrlo močnih ESP modula.
Iz tog su se razloga ESP moduli probili na tržištu i u tolikoj se mjeri proširili.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{esp32.jpg}
    \caption{Modul ESP32}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{CC3000.jpg}
    \caption{Modul CC3000}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=1]{rn131.jpg}
    \caption{Modul RN-131}
\end{figure}
%}}}

%MQTT {{{
\section{Message Queuing Telemetry Transport - \textbf{MQTT}}
MQTT je protokol široko primjenjen u \textit{IoT} sustavima temeljen na prijenosu poruka u režimu pretplate i objave.
Prijenos poruka se vrši preko TCP/IP protokola te se za to brine program na poslužitelju koji ima ulogu brokera.
Pretplata i objava se vrše na temelju teme (eng. \textit{topic}) gdje uređaji MQTT brokeru šalju poruke koje taj broker ovisno o temi šalje drugim uređajima koji su na tu temu pretplačeni.
Prava moć MQTT protokola su teme koje zamjenjuju MAC i IP adrese uređaja kako bi postavljanje infrastrukture postalo vrlo trivijalno i lagano za implementirati.
Tema je oblika \textit{"ovo/je/primjer/teme"} gdje je svaka razina teme odvojena separatorom \textit{"/"}.
Tema može imati bilokoliko razina te se one mogu adresirati pomoću zamjenskih znakova:
\begin{itemize}
    \item '+' - predstavlja jednu razinu u temi. Npr. tema \textit{"mojdom/prizemlje/+/temperatura"} će prikazivati sve poruke na temama \textit{"mojdom/prizemlje/kuhinja/temperatura"} te \textit{"mojdom/prizemlje/dnevnasoba/temperatura"}.
    \item '\#' - predstavlja više razina u temi. Npr. tema \textit{"mojdom/prizemlje/\#"} će prikazivati sve teme koje su podskup ove teme.
\end{itemize}
Ovakva struktura tema je vrlo pregledna i čitka te se na taj način može vrlo dobro logički odjeliti svaki čvor unutar takve mreže što čini MQTT protokol vrlo pogodnim za \textit{IoT} primjenu.
Svaki uređaj se nalazi na svojoj temi koja pobliže opisuje gdje se taj uređaj nalazi te pomoću teme možemo iščitati semantiku poslane poruke.
Poseban početni znak koji se može naći u temi je znak dolara \textit{"\$"} koji predstavlja unutarnje statistike samog MQTT brokera.
Na takve teme ne možemo objavljivati poruke a nisu ni podložne zamjenskim znakovima tako da ako se uređaj pretplati na temu \textit{"\#"} dobivat će sve poruke osim tih koje se nalaze na temama unutarnjih statistika.

Poruke mogu biti i očuvane (eng. \textit{retained}) tako da se prilikom objavljivanja poruke postavi zastavica očuvanja što MQTT brokrer interpretira tako da na toj temi sprema zadnju objavljenu poruku.
Tako očuvana poruka je objavljena svim novim uređajima koji se pretplačuju na tu temu u nekom kasnijem trenutku tako da ti uređaji dobivaju trenutne vrijednosti na takvim temama.
Ta je opcija vrlo korisna kod objavljivanja podataka primjerice nekih senzora zato što takvi uređaji odmah imaju trenutne vrijednosti s kojima odmah mogu početi baratati umjesto da čekaju tek sljedeću objavu.

MQTT klijent je bilokakav uređaj spojen na internet koji izvršava kod MQTT biblioteke te je spojeno na MQTT broker.
Klijenti su implementirani već za gotovo sve platforme (npr. Arduino, iOS, Android) u raznim programskim jezicima (npr. Python, C, C++, C\#, Java).
Također i drugi ESP modul može biti klijent tako da izvršava kod ovisno o poruci nekoga drugoga uređaja.

MQTT broker je program koji se izvršava na nekom poslužitelju te upravlja porukama i uređajima koji su na njega spojeni.
Brine se o pravim MAC i IP adresama uređaja na mreži koje su mu potrebne za samu realizaciju izmjena poruka kako se korisnici ne bi time trebali zamarati.
Također se brine i o autorizaciji uređaja na mreži tako da prava na pretplačivanje mogu biti implementirana pomoću korisničkih imena i lozinki kako bi se očuvala privatnost podataka i spriječile razne maliciozne aktivnosti.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{Topologija.png}
    \caption{Uloga MQTT brokera}
\end{figure}
%}}}

% Homie {{{
\section{Homie konvencija za MQTT protokol}
Homie konvencija je konvencija nastala iz potrebe zajednice za standardiziranim načinom komunikacije između različitih \textit{IoT} uređaja koji koriste MQTT protokol.
Njome se propisuje i implementira struktura tema i poruka kako bi se na temelju njih mogle implementirati pogodnosti kao što su praćenje verzija firmware-a, OTA (eng. \textit{Over The Air}) osvježavanja tog istog firmware-a, omogučuje automatsko otkrivanje uređaja na mreži te osigurava lakše poimanje mreže uređaja i struktura podataka.
Nalaže da je uređaj fizička instanca sklopovlja koji može logički prestavljati više čvorova.
Čvor je logički odvojen dio uređaja kao na primjer neki senzor temperature ili relej koji upravlja svjetlom.

Jedan čvor može imati više svojstava koja ga pobliže označuju kao na primjer RGB Led dioda koja može imati svojstva \textit{intenzitet} i \textit{boja}.
Svojstva mogu biti postavljiva ili ne postavljiva što čuva integritet tih svojstava tako da možemo objavljivanjem poruka mjenjati samo vrijednosti koje su promjenjive kao što su paljenje odnosno gašenje svjetla dok ne možemo mjenjati trenutnu temperaturu koju temperaturni senzor trenutno mjeri.
Atributi pobliže označavaju uređaje, čvorove i svojstva.
Oni se u temi označavaju sa početnim znakom "\$" i vrlo su bitni kod već spomenute implementacije automatskog otkrivanja uređaja i čvorova.
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{Homie.png}
    \caption{Logička podjela Homie konvencije}
\end{figure}

Svaka tema u ovoj konvenciji ima korijen \textit{"Homie"} nakon čega ide identifikator uređaja što može biti neki tekst definiran od strane programera ili uobičajeno MAC adresa mrežnog adaptera.
Svi atributi vezani uz uređaj slijede identifikatoru te počinju znakom "\$".
To su razni podaci od kojih je bitno za napomenuti:
\begin{itemize}
    \item \textit{\$mac} - MAC adresa
    \textit{\item \$localip} - lokalna IP adresa
    \item \textit{\$nodes} - čvorovi 
    \item \textit{\$state} - stanje uređaja
    \item \textit{\$stats} - statistika uređaja
    \item \textit{\$name} - ime uređaja
\end{itemize}

Nakon identifikatora uređaja slijedi identifikator čvora.
Identifikator čvora je definiran od strane programera te mora biti jedinstven za taj uređaj.
Atributi čvora su:
\begin{itemize}
    \item \textit{\$name} - ime
    \item \textit{\$type} - tip
    \item \textit{\$propertyes} - svojstva 
\end{itemize}
koji slijede identifikator čvora.

Slijedi svojstvo čvora koje također mora biti jedinstveno unutar jednoga čvora.
Atributi svojstva su ime (\textit{\$name}), postavljivost (\textit{\$settable}), mjerna jedinica (\textit{\$unit}), tip podataka (\textit{\$datatype}) te format (\textit{\$format}) koji opisuje opseg vrijednosti.

Svaka poruka mora biti zapisana u string formatu radi konzistentnosti između uređaja.

Primjer teme svjetla spojenog na relej na nekom uređaju po Homie konvenciji je:

"\textit{Homie/ime-uređaja/ime-čvora/upaljeno-svjetlo}".
%}}}

\chapter{Programska podrška za praćenje komunikacije više modula ESP8266 na WiFi mreži}
Kod implementacije programske podrške treba prvo napraviti topologiju sustava.
Sustav ima krajnje uređaje koji svoje poruke šalju poslužitelju te poslužitelj te poruke prosljeđuje dalje pretplačenim klijentima.
Pretplačeni klijent je u ovoj implementaciji program \textit{"parser.py"} koji, kako samo ime kaže, parsira poruke te ih sprema na odgovarajuč način u bazu podataka.
Bazi podataka treba pristupiti te se to vrši uz pomoć API-a koji vrši odgovarajući SQL upit te vraća sadržaj baze u JSON formatu.
Ideja topologije sustava je prikazana na slici~\ref{fig:mreza}.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{mreza.png}
    \caption{Topologija sustava}\label{fig:mreza}
\end{figure}

% Implementacija klijenta {{{
\section{Implementacija MQTT klijenta na ESP8266 modul pomoću Homie konvencije}
Arduino IDE je vrlo popularan u zajednici te je jako dobro podržan što od strane zajednice što od strane proizvođača Arduino mikrokontrolera.
Zajednica je iz tog razloga napravila biblioteku funkcija za Homie konvenciju za ESP8266 modul.
Biblioteka se lagano instalira pomoću ugrađenog upravljača bibliotekama u Arduino IDE-u upisom web sjedišta na kojoj se ta biblioteka nalazi te pritiskom ta tipku \textit{Install}.
U kodu se uključivanjem te biblioteke mogu koristiti sve funkcije upisom
\begin{lstlisting}[language=c++, caption=Uključivanje Homie biblioteke]
    #include <Homie.h>
\end{lstlisting}

Arduino mikrokontroleri zahtjevaju posebne funkcije \textit{setup()} i \textit{loop()}.
Uloga \textit{setup} funkcije ulazna funkcija u koji se pišu programski odsječci za postavljanje samog mikrokontrolera nakon čega se beskonačno puta ponavlja funkcija \textit{loop} u kojoj se nalazi kod koji se konstantno izvodi.
U duhu te konvencije se u \textit{setup} funkciji postavlja ime i verzija firmware-a za OTA postavljanje novog firmwera i poziva se setup metode instance Homie klase.
\begin{lstlisting}[language=c++]
    setup(){
        Homie_setFirmware("prvi-firmware", "1.0.0");
        Homie.setup();
    }
\end{lstlisting}

U \textit{loop} funkciji se poziva metoda \textit{loop()} Homie objekta čija je funkcija kontrola veze te pozivanje funkcije za upravljanje porukama kada su one objavljene na temu na koju je pretplaćen uređaj.

Za stavaranje novog čvora (u ovome slučaju LED diode) trebamo napraviti novi objekt klase \textit{HomieNode}
\begin{lstlisting}[language=c++]
HomieNode ledNode("led", "switch");
\end{lstlisting}
kojem se postavlja ime i tip.

Čvor \textit{ledNode} može imati svojstvo \textit{on} koje označava da LED dioda može biti upaljena ili ugašena.
To svojstvo je postavljivo jer se u ovome slučaju želi dioda paliti ili gasiti i definira se tako da se kao argument navede funkcija koja prilikom objave poruke pali ili gasi LED diodu.
\begin{lstlisting}[language=c++]
setup(){
    Homie_setFirmware("prvi-firmware", "1.0.0");
    ledNode.advertise("on").settable(ledHandler);
    Homie.setup();
}
\end{lstlisting}

Taj se programski kod treba nalaziti u \textit{setup} funkciji nakon postavljanja verzije firmware-a i prije funkcije za postavljanje Homie implementacije jer se prilikom tog postavljanja moraju navesti svi čvorovi koji se nalaze na tom uređaju.

Čvor ledNode je trenutno pretplačen na temu \textit{Homie/DeviceID/ledNode/on}.
Kad je na toj temi objavljena poruka funkcija ledHandler je pozvana i ona ovisno o sadržaju poruke upravlja LED diodom.
\begin{lstlisting}[language=C++]
bool ledHandler(const HomieRange& range, const String& value){
   if(value == "ON"){
    digitalWrite(led, HIGH);
    ledNode.setProperty("on").send("true");
    Serial.println("Led is on");
   }

   else if(value == "OFF"){
    digitalWrite(led, LOW);
    ledNode.setProperty("on").send("false");
    Serial.println("Led is off");
   }

   else {
    Serial.println("Wrong message!");
    return false;
   }
   return true;
}
\end{lstlisting}

% Boot modeovi i kako se konfigurira
Programiranje samog uređaja je pomoću Arduino SDK veoma trivijalno.
U padajućem izborniku se odabire odgovarajuć uređaj te se prema tome postavljaju sve ostale postavke te pritiskom na gumb \textit{Upload} se kod prevede i prebacuje u memoriju uređaja.
Pri tome na ESP8266 treba pin GPIO0 spojiti na logičku nulu kako bi prebacivanje programa bilo uspješno.

Uređaj se kod prvog priključivanja nalazi u konfiguracijskom režimu rada.
U takvom režimu se uređaj ponaša kao bežična pristupna točka lokalnoj mreži čije ime glasi \textit{Homie-xxxxxxxxxxxx} pri čemu je dio sa znakovima \textit{x} MAC adresa uređaja.
Računalom se spaja na uređaj pri čemu je lozinka točno ta MAC adresa i uređaj tako može primiti konfiguracijsku datoteku u JSON formatu.
Datoteka izgleda ovako:
\begin{lstlisting}[language=JavaScript]
{
    "name": "Ledica",
    "device-id": "ledica",
    "wifi": {
        "ssid": "<ime_mreze>",
        "password": "<lozinka>"
    },
    "mqtt": {
        "host": "<ip_adresa_MQTT_brokera>",
        "port": 1883,
        "base_topic": "devices/",
        "auth": false
    },
    "ota": {
        "enabled": true
    }

}
\end{lstlisting}
Funkcija postavki je:
\begin{itemize}
    \item name - Ime uređaja
    \item device-id - Jedinstveno ime uređaja - MAC adresa ako ne iskoristimo ovu postavku
    \item wifi - Ime i lozinka mreže na koju se uređaj spaja
    \item mqtt - Postavke MQTT brokera, IP adresa, port, korijenska tema (umjesto homie/), te autorizacija
    \item ota - Bežično reprogramiranje uređaja
\end{itemize}

U konfiguracijskom režimu rada uređaj izlaže funkcionalnosti JSON API-a preko kojeg možemo pozivati metode navedene u tablici~\ref{tab:API}
% Tablica 2 {{{
    \begin{table}[h]
        \centering
        \begin{tabular}{ |c|c|p{4cm}|p{4cm}| }
            \hline
            Metoda & Funkcija & Opis & Odgovori\\
            \hline
            GET & /heart & Provjera povezanosti sa uređajem & 204 No content \\
            \hline
            GET & /device-info & Informacije o uređaju & 200 OK + JSON datoteka\\
            \hline
            GET & /networks & Ispis svih vidljivih mreža & 200 OK, 503 Service Unavaliable \\
            \hline
            PUT & /config & Slanje konfuguracijske datoteke & 200 OK, 400 Bad Request, 403 Forbidden\\
            \hline
            GET & /wifi/connect & Povezivanje sa mrežom & 202 Accepted, 400 Bad Request\\
            \hline
            GET & /wifi/status & Ispis stanja veze & 200 OK + JSON datoteka\\
            \hline
            PUT & /proxy/control & Postavljanje funkcije posrednika & 200 OK, 400 Bad Request\\
            \hline
        \end{tabular}
        \caption{API pozivi}\label{tab:API}
    \end{table}
% }}}
Prema tome se JSON datoteka s postavkama se šalje na uređaj pomoću programa \textit{curl} koristeći /config funkciju naredbom:
\begin{lstlisting}[language=Bash]
curl -X PUT http://homie.config/config --header 'Content-Type: application/json' -d @config.json
\end{lstlisting}

nakon ćega uređaj vrača kod 200 OK i prelazi u normalan režim rada u kojemu izvršava kod iz memorije.
LED indikator svojom brzinom paljenja i gašenja naznačuje stanje veze s mrežom i MQTT brokerom.
Sporo paljenje i gašenje označava spajanje na mrežu dok brzo označava spajanje sa MQTT brokerom nakon čega se LED indikator gasi i uređaj nastavlja izvršavati svoj program.


%}}}

% Server {{{
\section{Postavljanje poslužitelja}
Uloga poslužitelja je pokretanje MQTT brokera i popratnih programa kao što su baza podataka, parser MQTT poruka i API.
Poslužitelju se pristupa pomoću ssh protokola i njime se upravlja preko naredbene linije.

SQLite baza podataka je vrlo lagana baza podataka koja koristi SQL sintaksu, ne zahtjeva posebne procese za rad i zapisuje promjene direktno u datoteku na disku.
Uloga baze podataka je ta da zapisuje u sebi stanja svih čvorova svih uređaja u sustavu za nadziranje kako bismo pomoću API-a mogli pristupiti tim podacima.

Platforma poslužitelja je raspian distribucija GNU/Linux operacijskog sustava jer je poslužitelj popularno malo računalo Raspberry PI.
Baza podata se instalira pomoću naredbe:
\begin{lstlisting}
    #sudo apt-get install sqlite
\end{lstlisting}
koja uz pomoć upravljača paketima \textit{apt} instalira sustav za upravljanje bazama podataka zajedno sa svim programima o kojima taj sustav ovisi.

Pokretanjem sustava za upravljanje bazom podataka se prikazuje naredbeni redak u koji upisom teksta SQL sintakse radimo novu
bazu podataka.
Struktura baze podataka je navedena u tablicama~\ref{tab:mqtt_table} i~\ref{tab:node_table}.
Dvije relacijske tablice su povezane zajedničkim ključem \textit{mac} te se u MQTT tablici čuvaju podaci vezani za sam uređaj dok se u \textit{node} tablici čuvaju podaci vezani za pojedine čvorove.
% MQTT table {{{
\begin{table}[H]
    \centering
    \begin{tabular}{ |c|l| }
        \hline
        Ime & Opis \\
        \hline
        \underline{name} & Ime uređaja\\
        \hline
        online & Status uređaja\\
        \hline
        localip & Lokalna IP adresa uređaja\\
        \hline
        \underline{mac} & MAC adresa uređaja\\
        \hline
        homie & Verzija implementacije Homie konvencije\\
        \hline
        signal & Jačina bežičnog signala\\
        \hline
        uptime & Vrijeme rada uređaja\\
        \hline
        fwname & Ime trenutnog firmware-a\\
        \hline
        fwvesion & Verzija trenutnog firmware-a\\
        \hline
        implementation & ??\\
        \hline
        config & JSON konfiguracijska datoteka\\
        \hline
        ota\_enabled & Omogučenost OTA\\
        \hline
        ota\_status & Status OTA\\
        \hline
    \end{tabular}
    \caption{Shema tablice mqtt}\label{tab:mqtt_table}
\end{table}

% }}}

% Node Table {{{
\begin{table}[H]
    \centering
    \begin{tabular}{ |c|l| }
        \hline
        Ime & Opis\\
        \hline
        mac & MAC adresa uređaja\\
        \hline
        \underline{node} & Ime čvora\\
        \hline
        type & Tip čvora\\
        \hline
        propertyes & Atributi čvora\\
        \hline
        node\_on & ??\\
        \hline
    \end{tabular}
    \caption{Shema tablice node}\label{tab:node_table}
\end{table}
% }}}
% }}}

% Parser {{{
\section{Parser}
Parser je program napisan u programskom jeziku Python te mu je zadaća primati MQTT poruke sa uređaja, parsirati te poruke i sadržaj spremati u bazu podataka.

Za povezivanje na MQTT broker koristi se \textit{phao.mqtt.client} biblioteka.
Instalacija te biblioteke se provodi uz pomoć programa \textit{pip} koji služi za instalaciju python paketa naredbom
\begin{lstlisting}[language=Bash]
    #pip -g install phao-mqtt
\end{lstlisting}
Opcija -g nalaže to da se taj paket instalira globalno na računalo a ne samo lokalno za taj projekt.
Biblioteka se u kod uključuje linijom
\begin{lstlisting}[language=Python]
    import phao.mqtt.client as mqtt
\end{lstlisting}
čime smo postavili alias \textit{mqtt} te možemo koristiti njene funkcije samo koristeći taj alias.
Povezivanje sa bazom podataka se vrši pomoću sqlite3 biblioteke koja se također instalira pomoću programa pip.
U glavnome djelu programa se povezuje na bazu podataka koja se izrađuje ako ona ne postoji te se provjerava postojanje tablica.
Zatim se spaja na MQTT broker i pokreće se beskonačna petlja koja čita poruke.
\begin{lstlisting}[language=Python, caption=Main funkcija programskog koda]
def main():
    global database
    database = sqlite3.connect("mqtt.db")
    check_database(database)

    client = mqtt.Client()
    client.on_connect = on_connect
    client.on_message = on_message
    client.connect(host, port, keepalive)

    client.loop_forever()
\end{lstlisting}
Client metode \textit{on\_connect} i \textit{on\_message} u funkcije implementirane od strane programera i uključuju se pomoću referenciranja.
Te funkcije su implementacije ponašanja parsera prilikom dotičnih događanja.
Pri uspješnom spajanju na MQTT broker se ispisuje poruka o uspjehu te se klijent pretplačuje na odgovarajuču temu što je u ovome slučaju korijenska tema željenih uređaja.
\begin{lstlisting}[language=Python, caption=Akcije prilikom spajanja na MQTT broker]
def on_connect(client, userdata, flags, rc):
    print("Connected!")
    client.subscribe(base_topic)
\end{lstlisting}
Prilikom primanja poruke se pokreče \textit{on\_message} funkcija koja čita poruku, parsira ju te sprema podatke u bazu podataka.
% on message {{{
\begin{lstlisting}[language=Python, caption=Parsiranje poruka i spremanje u bazu podataka]
def on_message(client, userdata, msg):
    global database
    cursor = database.cursor()
    atribute = msg.topic.split('/')[-1]
    atribute_value = msg.payload.decode('UTF-8')
    messages[atribute] = atribute_value
    if atribute == "\$type":
        node = msg.topic.split('/')[2]
        messages["node"] = node

    if (atribute == "\$online" and
        list(cursor.execute("select count(*) from mqtt;"))[0][0] == 0):

        cursor.execute(
                         """
                         insert into mqtt values (
                         '{}',
                         '{}',
                         '{}',
                         '{}',
                         '{}',
                         '{}',
                         '{}',
                         '{}',
                         '{}',
                         '{}',
                         '{}',
                         '{}',
                         '{}'
                         );
            """.format(
                messages["\$name"],
                messages["\$online"],
                messages["\$localip"],
                messages["\$mac"],
                messages["\$homie"],
                messages["signal"],
                messages["uptime"],
                messages["name"],
                messages["version"],
                messages["\$implementation"],
                messages["config"],
                messages["enabled"],
                messages["status"]
            )
                         )

        cursor.execute(
                         """
                         insert into node values (
                         '{}',
                         '{}',
                         '{}',
                         '{}',
                         '{}'
                         );
            """.format(
                messages["\$mac"],
                messages["node"],
                messages["\$type"],
                messages["\$properties"],
                messages["on"]
            )
                         )

    if(atribute == "uptime" and
         list(cursor.execute("select count(*) from mqtt;"))[0][0] == 1 and
         '\$online' in messages.keys()):

        update_mqtt = """
                            update mqtt
                            set
                            name = '{0}',
                            online = '{1}',
                            localip = '{2}',
                            mac = '{3}',
                            homie = '{4}',
                            signal = '{5}',
                            uptime = '{6}',
                            fwname = '{7}',
                            fwversion = '{8}',
                            implementation = '{9}',
                            config = '{10}',
                            ota_enabled = '{11}',
                            ota_status = '{12}'
                            where mac = '{3}';
                            """.format(messages["\$name"],
                                    messages["\$online"],
                                    messages["\$localip"],
                                    messages["\$mac"],
                                    messages["\$homie"],
                                    messages["signal"],
                                    messages["uptime"],
                                    messages["name"],
                                    messages["version"],
                                    messages["\$implementation"],
                                    messages["config"],
                                    messages["enabled"],
                                    messages["status"]
                                    )
        update_node = """update node
                            set
                            mac = '{0}',
                            node = '{1}',
                            type = '{2}',
                            properties = '{3}',
                            node_on = '{4}'
                            where mac = '{0}';
                            """.format(
                                messages["\$mac"],
                                messages["node"],
                                messages["\$type"],
                                messages["\$properties"],
                                messages["on"]
                            )

        cursor.execute(update_mqtt)
        cursor.execute(update_node)

    database.commit()

\end{lstlisting}
% }}}

Funkcija za provjeru baze podataka služi tome da pri prvom pokretanju bude provjereno postojanje samih tablica te kreiranje ako one ne postoje.
Ako pokušaj čitanja daje iznimku onda se stvaraju ispravne tablice čiji je kod zapisan u varijablama \textit{create\_mqtt\_sql} te \textit{create\_node\_sql}.
% stvaranje tablica {{{
\begin{lstlisting}[language=Python, caption=Funkcija za provjeru baze podataka]
create_mqtt_sql = """
                       create table mqtt(
                       name text,
                       online text,
                       localip text,
                       mac text primary key,
                       homie text,
                       signal text,
                       uptime text,
                       fwname text,
                       fwversion text,
                       implementation text,
                       config text,
                       ota_enabled text,
                       ota_status text
                       ); """
create_node_sql = """
                       create table node(
                       mac text,
                       node text,
                       type text,
                       properties text,
                       node_on text
                       );"""

def check_database(base):
    try:
        cursor = base.cursor()
        cursor.execute("select * from mqtt;")
    except sqlite3.OperationalError:
        cursor.execute(create_mqtt_sql)
        cursor.execute(create_node_sql)
        base.commit()
\end{lstlisting}
% }}}

Svi se podaci periodički objavljuju.
% }}}

% API {{{
\section{API}
REST API je aplikacijsko sučelje koje putem HTTP protokola primitkom zahtjeva izlaže ili mjenja izložene podatke.
REST je akronim za stil arhitekture \textit{Representational State Transfer}.
Korištenje ovakve arhitekture se preferira na internetu zbog količine prenesenih podataka za razliku od SOAP (eng. \textit{Simple Object Access Protokol}) arhitekture.

Programiranje REST API-a je olakšano uz pomoć Flask programskog okruženja za programski jezik Python.
Nudi već gotova rješenja za razvoj relativno jednostavnih aplikacija te se uključuje u program instalacijom pomoću alata \textit{pip} te uključivanjem u programski kod.

U Flask okruženju se resursi prikazuju kao klase kojima se pridjeljuje kraj putanje URL-a. 
To se postiže tako da se doda resurs navodeći odgovarajuću klasu te definicijom krajnje točke:
\begin{lstlisting}
 api.add_resource(Devices, "/devices")
\end{lstlisting}

Unutar klase se navode metode imena \textit{get, put, post} i \textit{delete} koje odgovaraju HTTP zahtjevima koji mogu biti poslani.
Svaka metoda implementira odgovarajuče akcije za tu klasu.

Aplikacija se pokreće u \textit{main} programskom odsječku pozivom \textit{run()} metode.
\begin{lstlisting}
app.run(port=5000)
\end{lstlisting}


Kompletan programski kod izgleda ovako:
\begin{lstlisting}[language=Python, caption=REST API programski kod]
from flask import Flask
from flask_restful import Resource, Api
from sqlalchemy import create_engine
from flask_jsonpify import jsonify

db = create_engine("sqlite:///mqtt.db")
app = Flask(__name__)
api = Api(app)


class Devices(Resource):
    def get(self):
        connection = db.connect()
        query = connection.execute("""
                                  select * from mqtt, node
                                  where mqtt.mac = node.mac;
                                  """)
        result = [dict(zip(tuple(query.keys()), i)) for i in query.cursor]
        return jsonify(result)


api.add_resource(Devices, "/devices")

if __name__ == "__main__":
    app.run(port=5000)
\end{lstlisting}

Get metoda implementira spajanje na bazu podataka, izvršavanje SQL upita te vraća JSON prikaz cijele baze podataka.
% }}}

\chapter{Zaključak}
Zaključak.

\bibliography{literatura}
\bibliographystyle{fer}

\begin{sazetak}
Sažetak na hrvatskom jeziku.

\kljucnerijeci{Ključne riječi, odvojene zarezima.}
\end{sazetak}

% TODO: Navedite naslov na engleskom jeziku.
\engtitle{Management Framework for ESP8266 WiFi Development Modules}
\begin{abstract}
Abstract.

\keywords{Keywords.}
\end{abstract}

\end{document}
